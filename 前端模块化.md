前端模块化解决的问题
- 命名空间的冲突

在这之前我们可能会用到命名空间或者是闭包作用域来解决这个问题
- 代码复用
- 代码依赖关系
## 当前的模块规范
目前主流的规范又三种 commonJS，AMD 和 CMD 以及 ES6 自带的模块规范。
### commonJS
#### 规范
commonJS的目的就是建立一个通用的模块化规范，让js不在限制在浏览器的执行环境中，使得js有能力像其它后台语言一样具备开发大型应用的能。
规范：
- 一个文件就是一个模块，拥有单独的作用域
- 普通方式定义的变量、函数、对象都属于该模块内
- 通过requir来加载模块
- 通过modules.export和exports来暴露模块中的内容，未暴露的内容都属于模块私有

Node实现了commonJS规范。由于commonJS是同步加载模块，在所有的依赖模块就绪之前代码是不会运行的，这对于后端来说并不是什么问题，但是在浏览器环境中，开发人员必须尽快的将内容呈现在页面上，虽然commonJs也有浏览器端的实现(tiny-browser-require)，commonJS在浏览器端并不是很适用。

#### CommonJS加载原理
`require`第一次加载这个脚本，就会执行整个脚本，然后生成一个对象缓存在内存中，以后再加载这个模块都是在内存中读取。这个对象差不多是下面这个样子
```
{
    id: 'module_name',
    exports: {...},
    loaded: true,
    // ...
    
}
```
#### 循环加载
前面说过CommonJS是同步加载的，当脚本在运行中一旦遇到`require`命令就会停下来去加载这个模块，模块加载中一旦有循环引用的情况，就只引入被循环引用的模块中已经执行的部分。模块执行完毕后将执行权交回给最开始的模块脚本继续执行。完成循环引用。

不过此时循环引用取到的值只是代码运行的位置的值，这个值在后续的代码中可能会被改变。循环引用中最好不要直接引用基本类型的值，用引用类型取值会取到最新的值。

记住：**CommonJS是同步的**

#### AMD（异步模块定义）
AMD是为浏览器设环境计的，是在RequireJS在推广的过程中对模块化定义的产出。AMD定义了一套js模块依赖异步加载标准，以适应浏览器环境的模块化。

模块通过`define`函数定义在闭包中，最后用`return`语句返回要暴露的接口。一个模块也可以依赖其它的模块。

RequireJS的机制就是利用利用head.appendChild将每一个依赖加载为一个script标签，requireJS等待所有的依赖加载完毕，计算出模块的调用顺序，然后依次调用。

实现了AMD的规范的最著名的就是RequireJS。由于是模块是异步加载的，所以模块的加载并不会阻塞主体代码执行。
模块的定义方式:
```
define(?moduleName, ?[deps], function(deps)) {
    // ...
    // 返回需要输出的功能，
    return 
}
```
特点：
- 异步加载，避免执行js带来的阻塞，会在所依赖的模块都加载后执行后面的回调函数
- 按需加载，在需要相应模块的地方再加载，避免了页面在初始化的时候就大量请求资源。
- 更方便的依赖管理，确保在加载了相应的依赖才会执行相关文件

#### CMD
CMD是sea.js在推广过程中形成的规范，也是针对浏览器的模块加载器，同时也有Node版的sea.js，可以方便的实现模在浏览器和服务端的共享。CMD更接近与commonJS

模块的定义方式:
```
define(?moduleName, ?[deps], function(require, exports, module)) {
    // ...
    exports.property = '111'
    // 也可以直接返回或者遵守commonJS的方式
}
```
#### ES6自带的规范
ES6 在语言层面支持了模块体系，但是这个体系既不像 commonJS 也不像 AMD。这是一个在浏览器端和服务器端通用的模块解决方案。CommonJS和AMD都是在运行时才加载模块，所以必须先全部加载整个模块，然后再从这个对象中读取需要的功能（运行时加载或动态加载）。但是import是在编译阶段就确定了模块的依赖关系，用export命令显式的指定要输出的代码，然后用import引入（编译时加载或静态加载），所以ES6只会引入需要的代码。


export用于规定模块的对外接口
import用于输入模块，import命令输出的变量是只读的，不能改变输出变量的引用或者值，import有提升效果，会提升到代码顶部。import不能使用变量和表达式。

还有一点要注意的是在模块内部是自动采用严格模式，模块内部顶层的`this`关键字返回是`undefined`。同一个模块加载多次，但是只运行一次。

最后`export`输出的只是一个接口，所以所有引用这个模块的代码得到也是同一个实例，在一个地方改变了模块内部的值，同样也会体现在另外引用这个模块的代码中

要注意的是这两个命令都不得出现在块级作用域内，否则就无法静态加载了。

CommonJS与ES6模块的差异：

- CommonJS模块输出的是模块的拷贝，ES6模块输出的是值的引用
- CommonJS是运行时加载，ES6是编译时输出只读接口。

CommonJS输出的是一个对象的浅拷贝，也就是说一旦这个模块被加载后，基本类型的值就不会受模块内部的影响。但是引用类型的值依然可以改变。

ES6在编译时输出的是一个只读的接口，在代码运行时会动态的通过接口获取模块最新的值。如果我们在模块之外操作模块内部的值就会动的改变模块内部的值。由于这个接口时只读的，如果给这个引入的接口赋值会报TypeError的错，这就跟给一个用`const`定义的常量重新赋值一样。

##### Node中加载ES6模块
ES6的模块与CommonJS是不兼容的，CommonJS的格式的模块与ES6格式的模块必须分开编写分开加载。ES6内部不能使用CommonJS支持的一些内部变量。

##### ES6 模块的循环加载



#### AMD VS CMD
相同点：
- 都是基于浏览器环境

不同点

- AMD是异步加载，提前执行，CMD是异步加载，延迟执行
- CMD推崇依赖就近，AMD推崇依赖提前
- CMD对开发调试更友好