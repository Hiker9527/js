首先我们要统一几个词：**执行环境**、**执行上下文**和**上下文**，其实这几个词指的都是一个概念，用英文表达都是**execution context**，只是在翻译的时候的几种不同的叫法，下文中我们将统一采用《javascript高级程序设计》中的叫法：**执行环境**。
### 0. 执行环境简介
我们首先看《javascript高级程序设计》中对于执行环境的解释：
> 执行环境是javascript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据决定了它们各自的行为。

大多数情况下我们在编写代码的过程中并不会刻意去考虑执行环境，但是执行环境在代码的运行中确实是无处不在的，就像我们很少去考虑空气的存在一样。执行环境中定义了在其中运行的代码中所有可以访问到的变量、函数、方法等等数据。

我们在平时可以简单的将执行环境等价为作用域链，这样也不会影响我们编写代码。不过实际上它们两个并不是一样的，如果我们将执行环境抽象为一个对象，那么作用域链就是这个对象的一个属性，最后执行环境对外的表现就是作用域链。

执行环境是代码得以运行的基础，深入理解执行环境将帮助我们更加深刻的理解javascript的执行机制。

### 1. 变量对象
每一个执行环境都有一个与之相关联的**变量对象**（variable object，简称VO），在这个对象中保存着执行环境中定义的所有的变量和函数声明，但是函数表达式并不会保存在其中。我们在编写代码的时候是无法访问执行环境的变量对象的，解释器运行代码的过程中可以在内部访问到变量对象中的数据。
```
var num = 1;
function func1() {
    var name = 'shawnwang';
}
(function func2() {
    // ...
})()
console.log(num);  // 1
console.log(func1); // func1...
console.log(func2); // func2 is not defined
```
我们在全局环境中运行上面的这段代码，此时全局执行环境中的变量对象包含如下变量：
<table>
<thead>
<th colspan="2">Global OV</th>
</thead>
<tbody>
<tr><td>num</td><td>1</td></tr>
<tr><td>func1</td><td><function></td></tr>
</tbody>
</table>
func1函数执行环境中的变量对象：

<table>
<thead>
<th colspan="2">func1 OV</th>
</thead>
<tbody>
<tr><td>name</td><td>shawnwang</td></tr>
</tbody>
</table>

在全局环境的变量对象中没有func2，因为func2是一个函数表达式，它不会被保存到变量对象中，在执行环境中就无法访问到。
> ##### 关于活动对象
> 与变量对象经常出现在一起的还有一个词叫做**活动对象**，活动对象是在函数执行过程中创建的一个内部对象，在函数执行环境中函数的活动对象会被当作执行环境的变量对象。但是它们之间并不是完全等价的关系，在其它的执行环境中并不存在活动对象这个概念。

### 2. 执行环境的创建
执行环境是在函数调用的时候才创建的，并不是在函数声明时就确定的。每当一个函数被调用时，就会创建一个自己的执行环境。执行环境的创建分为两个阶段：
1. 执行环境建立阶段
2. 代码执行阶段
我们将执行环境抽象为一个对象，结合下面这一段来分析这个过程：
```
function func(d) {
    var a;
    var b = 1;
    let e = 2;
    function c() {
        // ...
    }
}

func(4);
```
#### 2.1 建立阶段
执行环境创建的时机确切的说应该是在函数被调用后，但函数题还未真正执行之前。
1. 初始化作用域链在函数被**创建**时，会预先创建一个包含外部环境变量对象的**作用域链**（scope chain），并把作用域链保存在内部的属性`[[Scope]]`中。当函数被调用时，会复制`[[Scope]]`属性中的对象构建执行环境的作用域链。作用域链的本质是一个指向变量对象的指针列表，此时作用域链的前端是当前函数包含环境的变量对象，下一个变量对象就是包含环境的变量对象。就这样一只延续到全局环境的变量对象。
```
funcExecutionContext = {
    [[Scope]]: {...} // 作用域链
    variableObject: {
    }
}
```
2. 变量对象初始化阶段
    1. 此时解释器会创建该函数的**活动对象**（activation object）作为当前执行环境的变量对象，JavaScript解释器会用函数的`arguments`对象和其它命名参数来初始化活动对象。
    2. 活动对象初始化完成之后，会先检测执行环境中的函数声明，每检测到一个函数声明就会在变量对象中增加一个同名的属性，属性的值就是声明函数的引用，如果遇到同名的函数声明，后面就会覆盖前面的。
    3. 函数声明检测完毕之后，就会检测环境中的变量声明，如果变量对象中还不存在同名的属性，在变量对象中增加一个与变量名同名的属性，并将这个属性的值初始化为`undefined`。
    4. 活动对象初始化完成后推入作用域链的前端。
```
funcExecutionContext = {
    [[Scope]]: {...}, // 作用域链
    variableObject: {
        arguments: {
            0: 4,
            length: 1,
            // ...
        },
        d: 4,
        c: pointer to function c(),
        a: undefined,
        b: undefined,
    }
}
```
3. 确定执行环境`this`的指向。`this`就是指向当前的变量对象(或者是活动对象)。
```
funcExecutionContext = {
    [[Scope]]: {...}, // 作用域链
    variableObject: {
        arguments: {
            0: 4,
            length: 1,
            // ...
        },
        c: pointer to function c(),
        a: undefined,
        b: undefined,
        this: funcExecutionContext.variableObject // 指向当前的变量对象
    },
}
```

关于这几个过程的执行顺序我并没有完全弄清楚，不同的资料里的顺序也不尽相同。好在这个问题并不会对执行环境的理解造成很大的偏差。

#### 2.2 代码执行阶段
执行环境创建完成之后就进入代码的执行阶段了。在代码的执行阶段解释器就会对代码逐行解释执行。在创建阶段变量对象初始化的时候，检测变量声明的过程中只是对变量进行了初始化，在遇到变量的赋值语句时，就是重新给执行环境的变量对象赋值。函数在执行完成后执行环境就会是下面这样的：
```
funcExecutionContext = {
    [[Scope]]: {...}, // 作用域链
    variableObject: {
        arguments: {
            0: 4,
            length: 1,
            // ...
        },
        c: pointer to function c(),
        a: undefined,
        b: 1,
        this: funcExecutionContext.variableObject // 指向当前的变量对象
        e: 2,
    },
}
```


### 3. 执行环境栈

前面我们说全局执行环境是第一个被创建的执行环境，然后开始按顺序执行代码。解释器内部维护着一个执行环境栈，全局执行环境第一个被推入栈中，也就是在栈的最底端。每当代码遇到一个函数调用或者有块级作用域的代码块时，就会创建一个新的执行环境，并把这个环境推入环境栈中。而在函数执行完毕之后，环境栈就把这个执行环境弹出。所以栈的顶端永远是当前的执行环境，最底端是全局执行环境。这就是javascript单线程执行流的控制机制。

借用另外一篇文章中非常直观的一个例子来说明这个过程，代码如下：
```
function foo(i) {
    if (i===3) {
        return;
    } else {
        foo(++i);
    }
}

foo(0);
```
`foo`在声明之后我们就调用了它，给它传了参数0。在函数体内，如果`i`不等于`3`就给`i`后继续调用`foo`自己。`foo`每执行一次就会创建一个独立的执行环境，`foo`被嵌套的调用了三次就创建了三个执行环境，然后按照从后到先的顺序依次弹出环境栈被销毁直到全局执行环境。用一个动图表示：

![image](https://github.com/Hiker9527/js/blob/master/static/context-stack.gif)；

全局执行环境只有在宿主环境关闭的时候才会被销毁。

注意，在ES6之前，javascript语句并不存在块级作用域，例如`if`、`for`、`while`等语句并不会创建执行环境，所以也不存在作用域。
### 4. 变量提升
看完上面的分析，你应该就能明白在javascript中的函数声明提升和变量提升是怎么一回事了。在代码还未真正进入执行阶段，执行环境中已经对函数声明和变量声明进行了处理。使得我们在函数声明语句之前可以正常的调用函数，在变量声明之前使用变量就不会出现`undefined`。又由于变量声明的赋值是在代码执行阶段赋值的，这样的话如果在代码中有对与已声明函数同名的变量进行赋值的话，就会覆盖变量对象中的属性。

上面代码中我么还用了`let`关键字来声明变量，但是在代码执行之前这个变量并没有出现在变量对象中。这是因为ES6标准纠正了`var`关键字变量提升的这种奇怪做法，用`let`和`const`声明的变量一定要在声明之后才能使用，否则就会报错。函数声明的行为则没有变化。
```
function executionFunc() {
    console.log(num1);       // undefined
    console.log(func1);      // <function>
    console.log(num2);       // ReferenceError

    var num1 = 1;
    let num2 = 2;
    function func1() {
        // ...
    }
    var func1 = 0;
}
executionFunc();

```
`func`的变量声明在`func`的函数声明之后，但是函数声明并没有被覆盖。在`let`变量声明之前访问`num2`会抛出引用错误，说明`let`声明的变量不错在变量提升。
```
function executionFunc() {
    var num1 = 1;
    let num2 = 2;
    function func1() {
        // ...
    }
    var func1 = 0;
    
    console.log(num1);       // 1
    console.log(func1);      // 0
    console.log(num2);       // 2
}
```
代码执行之后变量声明覆盖了同名的函数声明。
### 5. 闭包中的执行环境
#### 5.1 闭包作用域链
闭包是一个很有用有时候也是一个很棘手的问题，我们不得不想写办法来处理闭包带来的问题。相信通过上面的铺垫，我们就能彻底理解闭包的种种表现。**闭包**是指有权访问另一个函数作用域中变量的函数。下面这个例子就是典型的闭包：
```
function returnFunc(name) {
    return function() {
        return name;
    }
}

var nameFunc = returnFunc('shawnwang');
```
`returnFunc`函数返回了一个匿名函数，这个匿名函数在`returnFunc`的执行环境内声明，所以它的作用域链中包含了`returnFunc`函数的活动对象以及全局执行环境。当`returnFunc`执行完毕后，虽然它的执行环境弹出环境栈，作用域链被销毁，但是`nameFunc`函数的作用域链中依然在引用它的活动对象，从而无法被回收清理，继而使得`nameFunc`可以继续访问`returnFunc`的活动对象。如果我们手动解除对匿名函数的引用，`returnFunc`的活动对象就可以被释放回收。

#### 5.2 解决闭包引用问题
由于闭包的作用域链中引用了包含环境的活动对象，所以在闭包中访问包含环境的任何变量都只能获取这个变量的最后一个值。下面这个经典的闭包案例相信大家都不陌生：
```
function createFuncs() {
    var new Array();
    for(var i = 0; i < 10; i++) {
        return result[i] = function() {
            return i;
        }
    }
    return result;
}
```
调用`createFuncs`，返回的数组中保存的每一个函数执行之后都会返回10。因为在数组的项中保存的每一个匿名函数都是一个闭包，在这个闭包中访问外部环境的活动对象中的变量`i`,只能得到`for`循环结束之后的`i`的值。

我们一般在解决这类问题的时候，都是在匿名函数外包裹一个立即执行函数，然后将`i`当作立即执行函数的参数传入其中，让闭包从立即执行函数的参数中获取当初想要得到的值。这种做法的本质就是利用立即执行函数再创建一个执行环境，这样闭包在创建的时候，其作用域链的前端引用的就是立即执行函数的活动对象。当我们把开始要用的变量当作参数传入立即执行函数中时，由于参数是按值传递，这个参数的值会按传进来的值保存在活动对象中。这样在闭包就可以访问到期望的值了。

除了立即执行函数，在支持ES6的环境中我们还可以利用块级作用域来解决这一问题。它们的原理都是一样的。

>《javascript高级程序设计》中有非常详细的解释，本节参考正式参考自该书7.2节。
### 总结
再次强调执行环境非常中要，我们编写的每一行代码都脱离不了执行环境而独自存在。在编写代码中，可以不关注，但是一定要理解。这也是一个前端工程师的进阶之路，做到知其然，也知其所以然。
