函数参数的传递方式有两种，按值传递和按引用传递（实际上还有一种方式是按指针传递，有兴趣可以自己去了解下）。JavaScript采用的就是按值传递的参数传递方式。

#### 按值传递VS按引用传递
在解释JavaScript函数参数传递方式之前，有必要先简单介绍一下按值传递和按引用传递的区别。

##### 按值传递
在按值传递这种方式下，实参和形参具有两个不同的地址空间。参数传递的的过程实质上就是将实参复制一份到形参的地址空间。当形参所在的执行环境销毁之后，形参同时也会被销毁。对形参的操作不会对实参产生影响。因为形参和实参是两个独立的存储空间。

##### 按引用传递
在按引用传递这种方式下，形参是引用类型的变量，实参传递给形参的是对象的一个地址，此时的形参可以看作是对象的一个别名。所以如果在函数内部操作形参就等同于操作函数外部的实参。

#### JavaScript中的按值传递
上面解释了按值传递和按引用传递，我们也知道JavaScript是按值传递的，好像到这里就没什么好讲的了。看一下这个例子：
```
let count = 1;
const obj = {
    name: 'hiker',
    sayName() {
        console.log(this.name);
    },
};

function changeArg(a, o) {
    a = 2;
    o.name = 'shawn';
}

changeArg(count, obj);

console.log(count);   // 1
obj.sayName();        // 'shawn'
```
在上面的这段代码中，我们给函数`changeArg()`传入了一个简单类型和一个引用类型。在函数内部对这两个参数进行了操作。最后的结果中`count`没有受函数内部的影响依然是原来的值，也印证了JavaScript中函数参数传递是按值传递。但是我们传入的对象却发生了改变。难道这不是按引用传递的特征？

再看下面这段代码：
```
let count = 1;
const obj = {
    name: 'hiker',
    sayName() {
        console.log(this.name);
    },
};

function changeArg(a, o) {
    a = 2;
    o = {
        name: 'shawn'
    };
}

changeArg(count, obj);

console.log(count);   // 1
obj.sayName();        // 'hiker'
```
这次我们在函数的内部重新给`o`这个参数赋值，这种情况下外部的对象并没有像之前那样发上改变。这个例子就证明了JavaScript中函数参数是按值传递的。

#### 总结

我们说按值传递就是形参对实参的一个拷贝。当实参是基本类型的情况下，就是对值进行直接的复制，但是当实参是引用类型时，此时实参中保存的也仅仅是对象的一个地址，并不是对象本身。这种情况下形参拷贝的就是实参所保存的对象的地址。所以我们不对形参重新赋值时，依然可以通过形参中复制的地址找到实参所指向的哪个对象，此时的操作也会实时反映到对象本身。一旦我们重复给形参赋值，就切断了它与对象的联系，再对重新赋值后的形参进行操作就无法影响原来的对象了。

